behavior example
	"Description" 
	version 1.0
	using 
		core.timer as timer, // enable core.* and maybe make it default?
		hm.raster as grids,
		core.filesystem as io, // core. should be automatically imported
		core.console as console,
		core.ui as ui,
		core.logger as log
		

// Test: actions (w and w/o parameters); verbs w/wout params; groups; metadata and tag for all. Then the rest. 

action main:
	emitter: sentence -> console.print(["Emitter said " + sentence])
	functor: x -> console.print(x)

// a functor
action functor:
	console.print("Dio porco ho bestemmiato, dio can")
	return "dio can"

// an emitter (fires periodically, no return, continues firing)
action emitter:
	timer.random(step=10.s): time -> fire "dio puto"

// reactor behavior: return is in the listener, exits action and removes listener when matched
action reactor:

@test
action test:

	// type prefix means constructor and 'file' is an agent, automatically assigned. 
	// Verbs are assigned based on type. Actions may follow immediately or later. Should have
	// a "use <type> (as 'alias')?" mechanism allowing ambiguities; using a full class path 
	// for straight Java matching is ugly and not feasible for parsing
	DigitalTwin dt
	
	france <- dt.observe('staging.vxii.basic.regions.france', year=2011)
	
	
	klab.new: 
		def dt $  // comma means: wait for fire of group before invoking next (removing the trigger)
 	dt.observe('staging.vxii.basic.testobserver'): 
 		def observer $
	dt.observe('staging.vxii.basic.testregion' :observer observer): 
		def region $

	assert [hasData(region.elevation)],
		   [hasData(region.slope)]
		:success ""
		:fail ""

	dt.close
	
@case(namespace='staging.vxii.basic')
action staging1(a, b):
	dt.new: dt.observe(
		observable = {{elevation:Porcodio}}
	)